
%subspace Decomposition
%cut direct sound
%scale direct sound
%rotate direct sound
%rejoin




% from single recording
%--------------------------------------------------------------------------------------------------------------------------
%% load and plot sofa file

% 包括对早期反射进行缩放并通过改变直达声到达时间与幅度来模拟在房间内
% 不同位置处的空间音频响应。

clc;
clear all;
close all;

% Start SOFA and load function library
% 加载SOFA相关API以及其他所需函数库，用于处理高阶Ambisonics和SOFA格式的脉冲响应

% get the parentFolder path
% 获取当前工作目录所在的父文件夹路径，便于添加需要的依赖路径
parentFolder = fileparts(pwd);

addpath(fullfile(parentFolder, 'API_MO'));
addpath(fullfile(parentFolder, 'Spherical-Harmonic-Transform-master'));
addpath(fullfile(parentFolder, 'Higher-Order-Ambisonics-master'));
addpath(genpath(fullfile(parentFolder, 'binaural_ambisonic_preprocessing-main')));
addpath(fullfile(parentFolder, 'audio_samples'));
addpath(fullfile(parentFolder, 'SRIR-Subspace-Decomposition-master'));
SOFAstart;


%run this to load decoder
% 如果之前没有加载Ambisonics配置，则运行load_ambisonic_configuration来获得Ambisonics解码器
if ~exist('aio_flag')
    load_ambisonic_configuration
end

% Load Variable Acoustics 6DoF Dataset (most reverberant set)
% 这里加载六自由度的SRIRs数据（最混响的版本），文件保存在 6dof_SRIRs_eigenmike_SH 文件夹中

parentFolder = fileparts(pwd);
irPath1 = fullfile(parentFolder, '6dof_SRIRs_eigenmike_SH/');
irName1 = '6DoF_SRIRs_eigenmike_SH_50percent_absorbers_enabled.sofa';

% download the SRIR.sofa from Github Release
% 如果本地没有该SOFA文件则从Github下载
url = 'https://github.com/ZhenxianLi/ZHENXIAN_SRIRextrapolation/releases/download/6dof_SRIRs_eigenmike_SH/6DoF_SRIRs_eigenmike_SH_50percent_absorbers_enabled.sofa';
% Construct the full path for the saved file
outputFile = fullfile(irPath1, irName1);
% Check if the file already exists to avoid duplicate downloads
if ~exist(outputFile, 'file')
    fprintf('start Download the file: %s\n', irName1);
    try
        % download to pass
        websave(outputFile, url);
        fprintf('downloadSucess: %s\n', outputFile);
    catch ME
        fprintf('downloadFail: %s\n', ME.message);
        return; % 终止执行
    end
else
    fprintf('File already exists, skipping download: %s\n', outputFile);
end

% 使用SOFAAPI加载该SOFA文件
sofa1 = SOFAload([irPath1,irName1]);
fs = sofa1.Data.SamplingRate;
%SOFAplotGeometry(sofa1);   % plot the source and listen position
close all;

%% check inf
% 这里查看SOFA文件中的一些元数据和尺寸信息
sofa1.GLOBAL_RoomType;
sofa1.GLOBAL_SOFAConventionsVersion;
sofa1.ListenerPosition;
sofa1.SourcePosition;
sofa1.EmitterPosition;
size(sofa1.Data);

% cheak the first  by hand
% 在每一组IR中，手动指定的早期反射到达索引，可以用峰值识别的方法获得这个集合
firstReflectionIndex=[487;697;674;528;579;621;606;515;616;726;499;658;861;543;742;939;971;1146;1071;900;1171];

%% calculate the sound speed
% 这里先获取IR的大小信息，然后仅取N=15（仅保留朝向数目为15）
% IROrder: 高阶Ambisonics阶数相关通道数量
% L: 单条IR的长度
sizeIR=size(sofa1.Data.IR);
N=sizeIR(1);
N=15;     %only facing=15 只取扬声器正面朝向麦克风的方向的组合 即前15个

IROrder=sizeIR(2); % how many order contain in the SRIR recording
L=sizeIR(3);        % sample length of the signal 

% find direct sound and fisrt early ref sound arrive time
% 寻找各IR直达声到达索引和对应距离，进而估计传播速度
speedSum=0;
distance=zeros(N,1);
directSoundValure=zeros(N,1);
for n=1:N
    IR_n=squeeze(sofa1.Data.IR(n,1,:));% n,1st order,full length
    [directSoundIndex,directSoundValure(n),pks,lcs]=findDirectSound(IR_n);
    distance(n)=sqrt(sum((sofa1.ListenerPosition(n,:)-sofa1.SourcePosition(n,:)).^2));
    directSoundTime(n)=directSoundIndex;     %time of direct sound(in samples)
    speedSum=(speedSum+distance(n)/directSoundTime(n));
    speed=speedSum/n;% in samples 
end

speedinSec=speed*fs;
% plot all N sound
% 如果pic1=1，则会可视化所有直达声位置以及早期反射峰值
pic1=0;
if pic1
    figure;
    for n=1:N
   
        subplot(7,3,n);%3 speaker; 7 mic
        plot(abs(IR_n));
        hold on;
        xline(directSoundIndex,'--g');
        xline(firstReflectionIndex(n),'--g');
        ylim([0,0.5]);
        xlim([0,4000]);
        hold on;
        plot(lcs,pks);
        title(num2str(n));
        hold on;
        
    end
    hold off
    %end for loop
end

% generate new IR-------------------------------
%% Subspace Decomposition and cut 
% 这里开始生成目标位置的SRIR。以第9条SRIR(S3L3，房间中心)作为原始参考点，
% 通过计算出目标听音位置与源位置的距离，以及直达声时延与振幅做缩放。

% start from 9, S3L3 ,center of room
% which postion use to
originListener=3;
originSpeaker=3;
% generate*************************************************************************************
% target position is the Speaker:targetSpeaker ;Mic:targetListener
% 这里指定要生成的目标话筒/扬声器组合
targetSpeaker=1;%1-3
targetListener=5;%1-7

%*********************************************************************************************
originRecordIndex=originListener*3-3+originSpeaker;% the index number of SRIR for origin postion 
targetRecordIndex=targetListener*3-3+targetSpeaker;% the index number of SRIR for target postion 

% set cut parameter
directSoundCutLeft=50;
directSoundCutRight=300;
earlyRefCutLength=400;

% read IR and postion
% IR_original 指的是参考IR（第9条）的数据

IR_original=sofa1.Data.IR(9,:,:);


SourcerPoint_Origin=sofa1.SourcePosition(9,:);
ListenerPoint_Origin=sofa1.ListenerPosition(9,:);

SourcerPoint_generate=sofa1.SourcePosition(targetRecordIndex,:);
ListenerPoint_generate=sofa1.ListenerPosition(targetRecordIndex,:);% the controlRecordNum recording it target
arrival_time_original=directSoundTime(9);%in samples
% Am_original=directSoundValure(9);



%% decomposition the direct and residual


srir_for_decomp = squeeze(IR_original).';
fs = fs;

% parameters for the subspace decomposition, see the function header of srirSubspaceDecomp for details
blockLenSmp = 32;
hopSizeSmp = blockLenSmp / 8;
kappa = 3;
numBlocksGsvSumAvg = 32;
residualEstimateLengthMs = 20;
decompositionTimeLimitMs = 100;
numBlocksSmoothThresh = 1;

[dirSrir, resSrir, numDirSubspaceComponents, gsvs, detectionThreshold, gsvSum, avgGsvSum] = ...
            srirSubspaceDecomp(srir_for_decomp, fs, blockLenSmp, hopSizeSmp, kappa, numBlocksGsvSumAvg, residualEstimateLengthMs, ...
                               decompositionTimeLimitMs, numBlocksSmoothThresh);


%% plot the decomposition result
plot_decomposition_result=1;
if plot_decomposition_result
srirLen = size(srir_for_decomp,1);
t = linspace(0, srirLen/fs-1/fs, srirLen).';
tBlocks = (0:hopSizeSmp:size(gsvs,1)*hopSizeSmp-hopSizeSmp)/fs;

fig_decomposition_sum = figure('Name', 'decomposition sum all channal');
hold on
plot(t*1000, (sum(abs(dirSrir), 2)), 'LineWidth', 2)
plot(t*1000, (sum(abs(resSrir), 2)), 'LineWidth', 2)
xlim([0,100])
xlabel('$t$ (smaples)', 'Interpreter', 'latex')
ylabel('$\| \cdot \|$ (dB)', 'Interpreter', 'latex')
legend({'$\mathbf{x}_\mathrm{d}(t)$', '$\mathbf{x}_\mathrm{r}(t)$'}, 'Interpreter', 'latex')
grid on

numChannels = size(srir_for_decomp,2);
cumsumGSVsColors = copper(numChannels);
cumsumGSVs = cumsum(gsvs,2);

fig_decomposition2 = figure('Name', 'decomposition GSV');
hold on
for ii = 1:numChannels
    if ii == numChannels
        hGSVCumsum = plot(tBlocks*1000, cumsumGSVs(:,ii), 'Color', cumsumGSVsColors(ii,:), 'LineWidth', 1.5);
    else
        plot(tBlocks*1000, cumsumGSVs(:,ii)*numChannels/ii, 'Color', cumsumGSVsColors(ii,:), 'LineWidth', 1.5)
    end
end
hAvgGSVs = plot(tBlocks*1000, avgGsvSum, 'k:', 'LineWidth', 1.5);
hDetectionThresh = plot(tBlocks*1000, detectionThreshold, 'k', 'LineWidth', 1.5);
grid on
xlabel('$t$ (ms)', 'Interpreter', 'latex')
xlim([0,100])
ylim([0,10])
legend([hGSVCumsum, hAvgGSVs, hDetectionThresh], ...
    {'cumulative sums of GSVs', 'subspace component threshold', 'detection threshold'}, ...
    'Interpreter', 'latex')
end

%倒置矩阵以与原本代码形式保持一致
dirSrir=dirSrir.';
resSrir=resSrir.';

%% scale the direct part

% fit distance - amiptude
% use rms
% Nface=15时，计算这15条面向不同方向时的直达声rms值，用于拟合随距离衰减模型
Nface=15;%only facing 15
rmsDirectSoundValure=zeros(Nface,1);

for n=1:Nface
    readIR_forFit=sofa1.Data.IR(n,:,:);
    arrival_time_forFit=firstReflectionIndex(n);
    ds=readIR_forFit(:,1,arrival_time_forFit-directSoundCutLeft:arrival_time_forFit+directSoundCutRight);
    rmsDirectSoundValure(n)=rms(squeeze(ds));
end

% 这里定义一个函数fun，用于求解距离与rms之间的指数衰减模型
fun = @(x)sseval(x,distance(1:Nface,1),rmsDirectSoundValure);
x0 = rand(2,1);
bestx = fminsearch(fun,x0);

% 可视化查看拟合情况
pic2=1;
if pic2
    fig_distance_scale_fit=figure('Name','distance_scale_fit');% check the fit
    scatter(distance,rmsDirectSoundValure);
    for n=1:N
        text(distance(n),rmsDirectSoundValure(n),num2str(n));
    end
    hold on;
    dislist=0:0.2:10;
    plot(dislist,bestx(1)*exp(-(bestx(2))*dislist));
    xlabel('distace/m')
    ylabel('rms Amplitude of Direct Sound')
end

% compute the time and Amiplitude
% 计算目标位置的直达声时延 arrival_time_generate 和幅度 Am_generate
distance_generate=sqrt(sum((SourcerPoint_generate-ListenerPoint_generate).^2));
distance_origianl=sqrt(sum((SourcerPoint_Origin-ListenerPoint_Origin).^2));
arrival_time_generate=floor(distance_generate/speed);       %  in samples
Am_generate=bestx(1)*exp(-(bestx(2))*distance_generate);
Am_original=bestx(1)*exp(-(bestx(2))*distance_origianl);


% 将直达声附近部分从dirSrir切片下来
directSound=dirSrir(:,arrival_time_original-directSoundCutLeft:arrival_time_original+directSoundCutRight);
% 根据幅度比例缩放直达声部分
directSound=directSound*(Am_generate/Am_original); %scale

%% Image Source Method to get early refliex

% 示例：定义房间、声源、麦克风位置，声速 = 343 m/s
roomSize = [7.87, 5.75, 2.91];       % 房间尺寸 (长, 宽, 高) 
sourcePos = sofa1.SourcePosition(targetRecordIndex,:);  % 声源坐标
micPos    = sofa1.ListenerPosition(targetRecordIndex,:);      % 麦克风坐标
maxRef    = 1;             % 只计算 maxRef 次镜像

% 调用函数
T = compute_DOA_ISM_with_plot(roomSize, sourcePos, micPos, maxRef, speedinSec); % ImageSource and plot
T.ArrTime

figure(fig_decomposition_sum);
old on;








aaaaaaa=1



%% re-join
% 重新拼接
% A是直达声到达前的部分（用0填充），B是直达声切片，C是早期反射，D是后续混响部分
% earlyRefCutLength=400，用于保证早期反射部分
A=zeros(25,arrival_time_generate-directSoundCutLeft-1);
B=squeeze(directSound);
C=squeeze(IR_original(:,:,arrival_time_generate+directSoundCutRight+1:arrival_time_generate+directSoundCutRight+earlyRefCutLength));%early ref
% C=C*(Am_generate/Am_original)/0.25;%scale C   (注释掉了这一行的缩放)
D=squeeze(IR_original(:,:,arrival_time_generate+directSoundCutRight+earlyRefCutLength+1:end));%reverb

IR_scale=[A,B,C,D];

%% plot and listen
% 可选地对处理后信号与原始信号进行可视化对比
pic3=0;
if pic3
    %sound(IR_scale(1,:),fs);
    figure;
    
    subplot(3,1,1);
    plot(abs(squeeze(IR_original(:,1,:))));
    legend('IR original');
    xlim([0 3000]);
    ylim([0 0.5]);
    
    subplot(3,1,2);
    plot(abs(squeeze(IR_scale(1,:))));
    legend('IR generate');
    xlim([0 3000]);
    ylim([0 0.5]);
    
    subplot(3,1,3);
    plot(abs(squeeze(sofa1.Data.IR(targetRecordIndex,1,:))));
    legend('IR record');
    xlim([0 3000]);
    ylim([0 0.5]);
end


%% rotate
% 通过计算两个位置(SourcerPoint_Origin - ListenerPoint_Origin)与
% (SourcerPoint_generate-ListenerPoint_generate)在球坐标系的偏差(azimuth,elevation)来做HOA信号旋转

% compute the sph
xyz1=SourcerPoint_Origin - ListenerPoint_Origin;
xyz2=SourcerPoint_generate-ListenerPoint_generate;
[az1,el1,r1]=cart2sph(xyz1(1),xyz1(2),xyz1(3));
[az2,el2,r2]=cart2sph(xyz2(1),xyz2(2),xyz2(3));
yaw=(az2-az1)/pi*180;
pitch=(el2-el1)/pi*180;
roll=0;

% reshape hoasig
% 将B（直达声部分）转置以符合rotateHOA_N3D函数的输入格式
hoasig=B.'; %B- reshape direct sound

% rotate
% 使用rotateHOA_N3D进行HOA信号旋转
hoasig_rot = rotateHOA_N3D(hoasig, yaw, pitch, roll);
B_rot=hoasig_rot.';

% re-join
% 将旋转后的直达声部分与早期反射、后期混响拼接
IR_rot=[A,B_rot,C,D];

%% plot and listen
% 对比原始、旋转后与实际目标录音的幅度差异
pic3=1;
if pic3
    %sound(IR_scale(1,:),fs);
    figure;
    
    subplot(3,1,1);
    plot(abs(squeeze(IR_original(:,1,:))));
    legend(['IR original ',num2str(3),num2str(3)]);
    xlim([0 8000]);
    ylim([0 0.5]);
    
    subplot(3,1,2);
    plot(abs(squeeze(IR_rot(1,:))));
    legend('IR rot');
    xlim([0 8000]);
    ylim([0 0.5]);
    
    subplot(3,1,3);
    plot(abs(squeeze(sofa1.Data.IR(targetRecordIndex,1,:))));
    legend(['IR record ',num2str(targetSpeaker),num2str(targetListener)]);
    xlim([0 8000]);
    ylim([0 0.5]);
end

%% render binaural and play
% 将HOA信号与双耳解码器卷积，得到双耳信号进行试听

% play all record
% 如果playAllRecord=1，可以循环播放所有录音
playAllRecord=0;
if playAllRecord
    for i=1:N/3
        speakerNum=3;
        recordNum=i*3-3+speakerNum;
        IR_test=squeeze(sofa1.Data.IR(recordNum,:,:)) ;
        waitingTime=zeros((i-1)*124223,2);
        binSound(IR_test,SH_ambisonic_binaural_decoder,Fs,waitingTime);
    end
end

% render and play IR_original(9) IR_generate IR_record
% 1.S3L3 2.generete 3.target recoeding
% 在这里分别渲染原始IR(第9条)、旋转后生成的IR以及目标位置实测IR，然后进行对比
doBinRenderIR=1;
if doBinRenderIR
    IR_Record=squeeze(sofa1.Data.IR(targetRecordIndex,:,:)) ;
    IR_original=squeeze(sofa1.Data.IR(9,:,:));
    
    binIR_original=binSound(IR_original,SH_ambisonic_binaural_decoder);
    binIR_generate=binSound(IR_rot,SH_ambisonic_binaural_decoder);
    binIR_record=binSound(IR_Record,SH_ambisonic_binaural_decoder);
    gaptime=zeros(0.3*fs,2);
    soundsc([binIR_original;gaptime;binIR_generate;gaptime;binIR_record],Fs);
    %soundsc([binIR_generate;gaptime;binIR_record],Fs);% only last 2 sound
end

% play controlRecord then generate IR conv with dry guitar
% 1.S3L3 2.generete 3.target recoeding
% 这里用一个干声(dry)信号与三种不同的IR做卷积来比较真实听感
doBinRenderSONG=0;
if doBinRenderSONG
    %song_Dry=audioread('speechdirectsound_48.wav');
    [~,ch]=size(song_Dry);
    if ch==2
        song_Dry=(song_Dry(:,1)+song_Dry(:,2))/2;
    end
    
    clear binSong_recordIR;
    clear binSong_originalIR;
    clear binSong_generateIR;
    
    for i=1:2 % L and R
        binSong_originalIR(:,i)=conv(song_Dry,binIR_original(:,i));
        binSong_generateIR(:,i)=conv(song_Dry,binIR_generate(:,i));
        binSong_recordIR(:,i)=conv(song_Dry,binIR_record(:,i));
    end
    
    gaptime=zeros(0.5*fs,2);% gap 0.5s*fs
    soundsc([binSong_originalIR;gaptime;binSong_generateIR;gaptime;binSong_recordIR],fs);
    
    if ~exist('Max')
        Max=1;
    end
    
    audiowrite(['S',num2str(targetSpeaker),'L',num2str(targetListener),'_Original33','.wav'],binSong_originalIR/Max,fs);
    audiowrite(['S',num2str(targetSpeaker),'L',num2str(targetListener),'_Rotate','.wav'],binSong_generateIR/Max,fs);
    %audiowrite(['S',num2str(useSpeaker),'L',num2str(useListener),'_Record','.wav'],binSong_recordIR/Max,fs);
end

%% declare function
%Find  direct sound loc and val
% 该函数用于找到直达声在IR中的索引和振幅（利用findpeaks在一定门限后找第一个峰）
function [locD,ValD,pks,lcs]=findDirectSound(ir)
absir=abs(ir);
noiseValuse=max(absir);
[pks,lcs]=findpeaks(absir,"MinPeakDistance",10,MinPeakHeight=0.2*noiseValuse);  %denosing,find peak
% Find the index of the peak representing the direct sound
locD=lcs(1);
ValD=pks(1);
end

% find A0 and alpha for distance - amipitude fit
% 该函数是用于计算指数衰减模型的误差和，用于fminsearch拟合出最优参数
function sse = sseval(x,tdata,ydata)
A = x(1);
lambda = x(2);
sse = sum((ydata - A*exp(-lambda*tdata)).^2);
end

% 该函数用于将高阶Ambisonics IR转换为双耳信号
function binIR=binSound(IR_test,SH_ambisonic_binaural_decoder)% render to a bin audio and play it
ambisonic_soundscape=IR_test.';

binaural_ambisonic_render = zeros(length(SH_ambisonic_binaural_decoder(1,:,1))+length(ambisonic_soundscape)-1,length(SH_ambisonic_binaural_decoder(1,1,:)));

% convolve each channel of the encoded signal with the decoder signal and sum the result
for i = 1:length(SH_ambisonic_binaural_decoder(:,1,1))
    
    binaural_ambisonic_render(:,1) = binaural_ambisonic_render(:,1) +  conv(SH_ambisonic_binaural_decoder(i,:,1),ambisonic_soundscape(:,i) );
    binaural_ambisonic_render(:,2) = binaural_ambisonic_render(:,2) +  conv(SH_ambisonic_binaural_decoder(i,:,2),ambisonic_soundscape(:,i) );
end

% compare the two binaural decoders by listening to both binaural renders consecutively
binIR=binaural_ambisonic_render;
end


%使用镜像源法计算并可视化 DOA、到达时间等信息
function T = compute_DOA_ISM_with_plot(roomSize, sourcePos, micPos, maxReflections, c)
% COMPUTE_DOA_ISM_WITH_PLOT  使用镜像源法计算并可视化 DOA、到达时间等信息
%
% T = compute_DOA_ISM_with_plot(roomSize, sourcePos, micPos, maxReflections, c)
%
% 输入参数：
%   roomSize       : [Lx, Ly, Lz] 房间尺寸 (米)
%   sourcePos      : [xs, ys, zs] 声源坐标 (米)
%   micPos         : [xm, ym, zm] 麦克风坐标 (米)
%   maxReflections : 最大镜像次数 (推荐 1~2)
%   c              : 声速 (默认 343 m/s)
%
% 输出：
%   T : 表格，包含以下列：
%       Nx, Ny, Nz : 镜像次数(分别代表 x,y,z 方向的镜像index)
%       Ximg, Yimg, Zimg : 镜像源位置
%       Distance : 从镜像源到麦克风的距离 (米)
%       ArrTime  : 到达时间 (秒)
%       Theta    : 方位角 (Azimuth, 弧度)
%       Phi      : 仰角 (Elevation, 弧度)
%
% 演示：
%   roomSize = [5, 4, 3];
%   sourcePos = [2, 1.5, 1.2];
%   micPos    = [3, 2, 1];
%   T = compute_DOA_ISM_with_plot(roomSize, sourcePos, micPos, 1, 343);

    if nargin < 5
        c = 343;  % 如果未指定声速，默认 343 m/s
    end
    
    % 解析房间尺寸
    Lx = roomSize(1);
    Ly = roomSize(2);
    Lz = roomSize(3);

    xs = sourcePos(1); ys = sourcePos(2); zs = sourcePos(3);
    xm = micPos(1);   ym = micPos(2);   zm = micPos(3);

    % 预分配结果
    Nx_arr = [];
    Ny_arr = [];
    Nz_arr = [];

    Ximg_arr = [];
    Yimg_arr = [];
    Zimg_arr = [];

    Dist_arr = [];
    ArrTime_arr = [];

    Theta_arr = [];
    Phi_arr   = [];

    % 计数器：一次反射、二次反射
    singleCount = 0;  
    doubleCount = 0;  
    
    figure('Name','ISM Visualization','NumberTitle','off'); 
    hold on;
    grid on;
    axis equal;
    xlabel('X (m)');
    ylabel('Y (m)');
    zlabel('Z (m)');
    title('Image Source Method (ISM) Visualization');
    
    % 绘制房间边界 (可选) - 简单画一个线框
    drawRoomFrame(0,0,0, Lx,Ly,Lz);

    % 绘制麦克风位置
    plot3(xm, ym, zm, 'ks', 'MarkerFaceColor','k','MarkerSize',8);
    text(xm, ym, zm, '  Mic', 'Color','k','FontWeight','bold');
    
    % 绘制原始声源 (nx=0,ny=0,nz=0)
    plot3(xs, ys, zs, 'r^', 'MarkerFaceColor','r','MarkerSize',8);
    text(xs, ys, zs, '  Source', 'Color','r','FontWeight','bold');

    % 遍历镜像次数
    for nx = -maxReflections:maxReflections
        for ny = -maxReflections:maxReflections
            for nz = -maxReflections:maxReflections

                % sumOrder = abs(nx)+abs(ny)+abs(nz)
                sumOrder = abs(nx) + abs(ny) + abs(nz);

                % 如果 sumOrder 在 [1, maxReflections]，则表示一次或二次(或更多)反射
                % 这里 maxReflections=2 时, sumOrder=1 ->一次, sumOrder=2->二次
                if sumOrder >= 1 && sumOrder <= maxReflections
                    % 计算镜像源位置
                    x_img = xs + nx * Lx;
                    y_img = ys + ny * Ly;
                    z_img = zs + nz * Lz;
                
                    % 方向向量：镜像源 -> 麦克风
                    d = [x_img - xm, y_img - ym, z_img - zm];
                
                    % 计算距离
                    dist = norm(d); % 欧几里得距离
                    % 计算到达时间
                    arrTime = dist / c;
                
                    % 计算 DOA (方位角 & 仰角)
                    theta = atan2(d(2), d(1));  % 方位角
                    phi   = atan2(d(3), sqrt(d(1)^2 + d(2)^2)); % 仰角

                    % 存储结果
                    Nx_arr = [Nx_arr; nx];
                    Ny_arr = [Ny_arr; ny];
                    Nz_arr = [Nz_arr; nz];

                    Ximg_arr = [Ximg_arr; x_img];
                    Yimg_arr = [Yimg_arr; y_img];
                    Zimg_arr = [Zimg_arr; z_img];

                    Dist_arr = [Dist_arr; dist];
                    ArrTime_arr = [ArrTime_arr; arrTime];

                    Theta_arr = [Theta_arr; theta];
                    Phi_arr   = [Phi_arr; phi];
                
                    % 区分一次反射( sumOrder=1 )与二次反射( sumOrder=2 )
                    if sumOrder == 1
                        singleCount = singleCount + 1;
                        % 绘制成绿色圆点(示例)
                        plot3(x_img, y_img, z_img, 'go','MarkerFaceColor','g','MarkerSize',5);
                    elseif sumOrder == 2
                        doubleCount = doubleCount + 1;
                        % 绘制成蓝色圆点(示例)
                        plot3(x_img, y_img, z_img, 'bo','MarkerFaceColor','b','MarkerSize',5);
                    end

                    % 连线：麦克风 -> 镜像源
                    line([xm x_img],[ym y_img],[zm z_img], ...
                         'Color',[0.3 0.3 0.8],'LineStyle','--');
                end
            end
        end
    end
    
    % 输出表格
    T = table(Nx_arr, Ny_arr, Nz_arr, ...
              Ximg_arr, Yimg_arr, Zimg_arr, ...
              Dist_arr, ArrTime_arr, Theta_arr, Phi_arr, ...
        'VariableNames', {'Nx','Ny','Nz','Ximg','Yimg','Zimg','Distance','ArrTime','Theta','Phi'});
    
    % 在 Command Window 中显示表格
    disp(T);

    % 显示统计结果
    fprintf('\n--- Reflection Stats ---\n');
    fprintf('  一次反射数量: %d\n', singleCount);
    fprintf('  二次反射数量: %d\n', doubleCount);
    
    % 调整视角
    view(3);
    hold off;
end

% 辅助函数：绘制房间外框
function drawRoomFrame(x0, y0, z0, Lx, Ly, Lz)
% 在当前坐标轴绘制一个线框，用于简单展示房间
    X = [x0, x0+Lx, x0+Lx, x0,     x0,     x0+Lx, x0+Lx, x0];
    Y = [y0, y0,     y0+Ly, y0+Ly, y0,     y0,     y0+Ly, y0+Ly];
    Z = [z0, z0,     z0,     z0,     z0+Lz, z0+Lz, z0+Lz, z0+Lz];
    edges = [1 2 3 4 1 5 6 7 8 5 6 2 3 7 8 4];
    for i=1:length(edges)-1
       plot3([X(edges(i)) X(edges(i+1))], [Y(edges(i)) Y(edges(i+1))], ...
             [Z(edges(i)) Z(edges(i+1))], 'k-','LineWidth',1.0);
       hold on;
    end
end
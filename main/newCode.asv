
%subspace Decomposition
%cut direct sound
%scale direct sound
%rotate direct sound
%rejoin




% from single recording
%--------------------------------------------------------------------------------------------------------------------------
%% load and plot sofa file

% 包括对早期反射进行缩放并通过改变直达声到达时间与幅度来模拟在房间内
% 不同位置处的空间音频响应。

clc;
clear all;
close all;

% Start SOFA and load function library
% 加载SOFA相关API以及其他所需函数库，用于处理高阶Ambisonics和SOFA格式的脉冲响应

% get the parentFolder path
% 获取当前工作目录所在的父文件夹路径，便于添加需要的依赖路径
parentFolder = fileparts(pwd);

addpath(fullfile(parentFolder, 'API_MO'));
addpath(fullfile(parentFolder, 'Spherical-Harmonic-Transform-master'));
addpath(fullfile(parentFolder, 'Higher-Order-Ambisonics-master'));
addpath(genpath(fullfile(parentFolder, 'binaural_ambisonic_preprocessing-main')));
addpath(fullfile(parentFolder, 'audio_samples'));
addpath(fullfile(parentFolder, 'SRIR-Subspace-Decomposition-master'));
SOFAstart;


%run this to load decoder
% 如果之前没有加载Ambisonics配置，则运行load_ambisonic_configuration来获得Ambisonics解码器
if ~exist('aio_flag')
    load_ambisonic_configuration
end

% Load Variable Acoustics 6DoF Dataset (most reverberant set)
% 这里加载六自由度的SRIRs数据（最混响的版本），文件保存在 6dof_SRIRs_eigenmike_SH 文件夹中

parentFolder = fileparts(pwd);
irPath1 = fullfile(parentFolder, '6dof_SRIRs_eigenmike_SH/');
irName1 = '6DoF_SRIRs_eigenmike_SH_50percent_absorbers_enabled.sofa';

% download the SRIR.sofa from Github Release
% 如果本地没有该SOFA文件则从Github下载
url = 'https://github.com/ZhenxianLi/ZHENXIAN_SRIRextrapolation/releases/download/6dof_SRIRs_eigenmike_SH/6DoF_SRIRs_eigenmike_SH_50percent_absorbers_enabled.sofa';
% Construct the full path for the saved file
outputFile = fullfile(irPath1, irName1);
% Check if the file already exists to avoid duplicate downloads
if ~exist(outputFile, 'file')
    fprintf('start Download the file: %s\n', irName1);
    try
        % download to pass
        websave(outputFile, url);
        fprintf('downloadSucess: %s\n', outputFile);
    catch ME
        fprintf('downloadFail: %s\n', ME.message);
        return; % 终止执行
    end
else
    fprintf('File already exists, skipping download: %s\n', outputFile);
end

% 使用SOFAAPI加载该SOFA文件
sofa1 = SOFAload([irPath1,irName1]);
fs = sofa1.Data.SamplingRate;
%SOFAplotGeometry(sofa1);   % plot the source and listen position

%% check inf
% 这里查看SOFA文件中的一些元数据和尺寸信息
sofa1.GLOBAL_RoomType;
sofa1.GLOBAL_SOFAConventionsVersion;
sofa1.ListenerPosition;
sofa1.SourcePosition;
sofa1.EmitterPosition;
size(sofa1.Data);

% cheak the first  by hand
% 在每一组IR中，手动指定的早期反射到达索引，可以用峰值识别的方法获得这个集合
firstReflectionIndex=[487;697;674;528;579;621;606;515;616;726;499;658;861;543;742;939;971;1146;1071;900;1171];

%% calculate the sound speed
% 这里先获取IR的大小信息，然后仅取N=15（仅保留朝向数目为15）
% IROrder: 高阶Ambisonics阶数相关通道数量
% L: 单条IR的长度
sizeIR=size(sofa1.Data.IR);
N=sizeIR(1);
N=15;     %only facing=15 只取扬声器正面朝向麦克风的方向的组合 即前15个

IROrder=sizeIR(2); % how many order contain in the SRIR recording
L=sizeIR(3);        % sample length of the signal 

% find direct sound and fisrt early ref sound arrive time
% 寻找各IR直达声到达索引和对应距离，进而估计传播速度
speedSum=0;
distance=zeros(N,1);
directSoundValure=zeros(N,1);
for n=1:N
    IR_n=squeeze(sofa1.Data.IR(n,1,:));% n,1st order,full length
    [directSoundIndex,directSoundValure(n),pks,lcs]=findDirectSound(IR_n);
    distance(n)=sqrt(sum((sofa1.ListenerPosition(n,:)-sofa1.SourcePosition(n,:)).^2));
    directSoundTime(n)=directSoundIndex;     %time of direct sound(in samples)
    speedSum=(speedSum+distance(n)/directSoundTime(n));
    speed=speedSum/n;% in samples
    
end

% plot all N sound
% 如果pic1=1，则会可视化所有直达声位置以及早期反射峰值
pic1=0;
if pic1
    figure;
    for n=1:N
   
        subplot(7,3,n);%3 speaker; 7 mic
        plot(abs(IR_n));
        hold on;
        xline(directSoundIndex,'--g');
        xline(firstReflectionIndex(n),'--g');
        ylim([0,0.5]);
        xlim([0,4000]);
        hold on;
        plot(lcs,pks);
        title(num2str(n));
        hold on;
        
    end
    hold off
    %end for loop
end

% generate new IR-------------------------------
%% Subspace Decomposition and cut 
% 这里开始生成目标位置的SRIR。以第9条SRIR(S3L3，房间中心)作为原始参考点，
% 通过计算出目标听音位置与源位置的距离，以及直达声时延与振幅做缩放。

% start from 9, S3L3 ,center of room
% which postion use to
originListener=3;
originSpeaker=3;
% generate*************************************************************************************
% target position is the Speaker:targetSpeaker ;Mic:targetListener
% 这里指定要生成的目标话筒/扬声器组合
targetSpeaker=1;%1-3
targetListener=5;%1-7

%*********************************************************************************************
originRecordIndex=originListener*3-3+originSpeaker;% the index number of SRIR for origin postion 
targetRecordIndex=targetListener*3-3+targetSpeaker;% the index number of SRIR for target postion 

% set cut parameter
directSoundCutLeft=50;
directSoundCutRight=300;
earlyRefCutLength=400;

% read IR and postion
% IR_original 指的是参考IR（第9条）的数据

IR_original=sofa1.Data.IR(9,:,:);


SourcerPoint_Origin=sofa1.SourcePosition(9,:);
ListenerPoint_Origin=sofa1.ListenerPosition(9,:);

SourcerPoint_generate=sofa1.SourcePosition(targetRecordIndex,:);
ListenerPoint_generate=sofa1.ListenerPosition(targetRecordIndex,:);% the controlRecordNum recording it target
arrival_time_original=directSoundTime(9);%in samples
% Am_original=directSoundValure(9);



%% decomposition the direct and residual


srir_for_decomp = squeeze(IR_original).';
fs = fs;

% parameters for the subspace decomposition, see the function header of srirSubspaceDecomp for details
blockLenSmp = 32;
hopSizeSmp = blockLenSmp / 8;
kappa = 3;
numBlocksGsvSumAvg = 32;
residualEstimateLengthMs = 20;
decompositionTimeLimitMs = 100;
numBlocksSmoothThresh = 1;

[dirSrir, resSrir, numDirSubspaceComponents, gsvs, detectionThreshold, gsvSum, avgGsvSum] = ...
            srirSubspaceDecomp(srir_for_decomp, fs, blockLenSmp, hopSizeSmp, kappa, numBlocksGsvSumAvg, residualEstimateLengthMs, ...
                               decompositionTimeLimitMs, numBlocksSmoothThresh);


%% plot the decomposition result
plot_decomposition_result=1;
if plot_decomposition_result
srirLen = size(srir_for_decomp,1);
t = linspace(0, srirLen/fs-1/fs, srirLen).';
tBlocks = (0:hopSizeSmp:size(gsvs,1)*hopSizeSmp-hopSizeSmp)/fs;

figure
hold on
plot(t*1000, (sum(abs(dirSrir), 2)), 'LineWidth', 2)
plot(t*1000, (sum(abs(resSrir), 2)), 'LineWidth', 2)
xlim([0,100])
xlabel('$t$ (smaples)', 'Interpreter', 'latex')
ylabel('$\| \cdot \|$ (dB)', 'Interpreter', 'latex')
legend({'$\mathbf{x}_\mathrm{d}(t)$', '$\mathbf{x}_\mathrm{r}(t)$'}, 'Interpreter', 'latex')
grid on

numChannels = size(srir_for_decomp,2);
cumsumGSVsColors = copper(numChannels);
cumsumGSVs = cumsum(gsvs,2);

figure
hold on
for ii = 1:numChannels
    if ii == numChannels
        hGSVCumsum = plot(tBlocks*1000, cumsumGSVs(:,ii), 'Color', cumsumGSVsColors(ii,:), 'LineWidth', 1.5);
    else
        plot(tBlocks*1000, cumsumGSVs(:,ii)*numChannels/ii, 'Color', cumsumGSVsColors(ii,:), 'LineWidth', 1.5)
    end
end
hAvgGSVs = plot(tBlocks*1000, avgGsvSum, 'k:', 'LineWidth', 1.5);
hDetectionThresh = plot(tBlocks*1000, detectionThreshold, 'k', 'LineWidth', 1.5);
grid on
xlabel('$t$ (ms)', 'Interpreter', 'latex')
xlim([0,100])
ylim([0,10])
legend([hGSVCumsum, hAvgGSVs, hDetectionThresh], ...
    {'cumulative sums of GSVs', 'subspace component threshold', 'detection threshold'}, ...
    'Interpreter', 'latex')
end

%倒置矩阵以与原本代码形式保持一致
dirSrir=dirSrir.';
resSrir=resSrir.';

%% scale the direct part

% fit distance - amiptude
% use rms
% Nface=15时，计算这15条面向不同方向时的直达声rms值，用于拟合随距离衰减模型
Nface=15;%only facing 15
rmsDirectSoundValure=zeros(Nface,1);

for n=1:Nface
    readIR_forFit=sofa1.Data.IR(n,:,:);
    arrival_time_forFit=firstReflectionIndex(n);
    ds=readIR_forFit(:,1,arrival_time_forFit-directSoundCutLeft:arrival_time_forFit+directSoundCutRight);
    rmsDirectSoundValure(n)=rms(squeeze(ds));
end

% 这里定义一个函数fun，用于求解距离与rms之间的指数衰减模型
fun = @(x)sseval(x,distance(1:Nface,1),rmsDirectSoundValure);
x0 = rand(2,1);
bestx = fminsearch(fun,x0);

% 可视化查看拟合情况
pic2=1;
if pic2
    figure;% check the fit
    scatter(distance,rmsDirectSoundValure);
    for n=1:N
        text(distance(n),rmsDirectSoundValure(n),num2str(n));
    end
    hold on;
    dislist=0:0.2:10;
    plot(dislist,bestx(1)*exp(-(bestx(2))*dislist));
    xlabel('distace/m')
    ylabel('rms Amplitude of Direct Sound')
end

% compute the time and Amiplitude
% 计算目标位置的直达声时延 arrival_time_generate 和幅度 Am_generate
distance_generate=sqrt(sum((SourcerPoint_generate-ListenerPoint_generate).^2));
distance_origianl=sqrt(sum((SourcerPoint_Origin-ListenerPoint_Origin).^2));
arrival_time_generate=floor(distance_generate/speed);       %  in samples
Am_generate=bestx(1)*exp(-(bestx(2))*distance_generate);
Am_original=bestx(1)*exp(-(bestx(2))*distance_origianl);


% 将直达声附近部分从dirSrir切片下来
directSound=dirSrir(:,arrival_time_original-directSoundCutLeft:arrival_time_original+directSoundCutRight);
% 根据幅度比例缩放直达声部分
directSound=directSound*(Am_generate/Am_original); %scale

%% re-join
% 重新拼接
% A是直达声到达前的部分（用0填充），B是直达声切片，C是早期反射，D是后续混响部分
% earlyRefCutLength=400，用于保证早期反射部分
A=zeros(25,arrival_time_generate-directSoundCutLeft-1);
B=squeeze(directSound);
C=squeeze(IR_original(:,:,arrival_time_generate+directSoundCutRight+1:arrival_time_generate+directSoundCutRight+earlyRefCutLength));%early ref
% C=C*(Am_generate/Am_original)/0.25;%scale C   (注释掉了这一行的缩放)
D=squeeze(IR_original(:,:,arrival_time_generate+directSoundCutRight+earlyRefCutLength+1:end));%reverb

IR_scale=[A,B,C,D];

%% plot and listen
% 可选地对处理后信号与原始信号进行可视化对比
pic3=0;
if pic3
    %sound(IR_scale(1,:),fs);
    figure;
    
    subplot(3,1,1);
    plot(abs(squeeze(IR_original(:,1,:))));
    legend('IR original');
    xlim([0 3000]);
    ylim([0 0.5]);
    
    subplot(3,1,2);
    plot(abs(squeeze(IR_scale(1,:))));
    legend('IR generate');
    xlim([0 3000]);
    ylim([0 0.5]);
    
    subplot(3,1,3);
    plot(abs(squeeze(sofa1.Data.IR(targetRecordIndex,1,:))));
    legend('IR record');
    xlim([0 3000]);
    ylim([0 0.5]);
end


%% rotate
% 通过计算两个位置(SourcerPoint_Origin - ListenerPoint_Origin)与
% (SourcerPoint_generate-ListenerPoint_generate)在球坐标系的偏差(azimuth,elevation)来做HOA信号旋转

% compute the sph
xyz1=SourcerPoint_Origin - ListenerPoint_Origin;
xyz2=SourcerPoint_generate-ListenerPoint_generate;
[az1,el1,r1]=cart2sph(xyz1(1),xyz1(2),xyz1(3));
[az2,el2,r2]=cart2sph(xyz2(1),xyz2(2),xyz2(3));
yaw=(az2-az1)/pi*180;
pitch=(el2-el1)/pi*180;
roll=0;

% reshape hoasig
% 将B（直达声部分）转置以符合rotateHOA_N3D函数的输入格式
hoasig=B.'; %B- reshape direct sound

% rotate
% 使用rotateHOA_N3D进行HOA信号旋转
hoasig_rot = rotateHOA_N3D(hoasig, yaw, pitch, roll);
B_rot=hoasig_rot.';

% re-join
% 将旋转后的直达声部分与早期反射、后期混响拼接
IR_rot=[A,B_rot,C,D];

%% plot and listen
% 对比原始、旋转后与实际目标录音的幅度差异
pic3=1;
if pic3
    %sound(IR_scale(1,:),fs);
    figure;
    
    subplot(3,1,1);
    plot(abs(squeeze(IR_original(:,1,:))));
    legend(['IR original ',num2str(3),num2str(3)]);
    xlim([0 8000]);
    ylim([0 0.5]);
    
    subplot(3,1,2);
    plot(abs(squeeze(IR_rot(1,:))));
    legend('IR rot');
    xlim([0 8000]);
    ylim([0 0.5]);
    
    subplot(3,1,3);
    plot(abs(squeeze(sofa1.Data.IR(targetRecordIndex,1,:))));
    legend(['IR record ',num2str(targetSpeaker),num2str(targetListener)]);
    xlim([0 8000]);
    ylim([0 0.5]);
end

%% render binaural and play
% 将HOA信号与双耳解码器卷积，得到双耳信号进行试听

% play all record
% 如果playAllRecord=1，可以循环播放所有录音
playAllRecord=0;
if playAllRecord
    for i=1:N/3
        speakerNum=3;
        recordNum=i*3-3+speakerNum;
        IR_test=squeeze(sofa1.Data.IR(recordNum,:,:)) ;
        waitingTime=zeros((i-1)*124223,2);
        binSound(IR_test,SH_ambisonic_binaural_decoder,Fs,waitingTime);
    end
end

% render and play IR_original(9) IR_generate IR_record
% 1.S3L3 2.generete 3.target recoeding
% 在这里分别渲染原始IR(第9条)、旋转后生成的IR以及目标位置实测IR，然后进行对比
doBinRenderIR=1;
if doBinRenderIR
    IR_Record=squeeze(sofa1.Data.IR(targetRecordIndex,:,:)) ;
    IR_original=squeeze(sofa1.Data.IR(9,:,:));
    
    binIR_original=binSound(IR_original,SH_ambisonic_binaural_decoder);
    binIR_generate=binSound(IR_rot,SH_ambisonic_binaural_decoder);
    binIR_record=binSound(IR_Record,SH_ambisonic_binaural_decoder);
    gaptime=zeros(0.3*fs,2);
    soundsc([binIR_original;gaptime;binIR_generate;gaptime;binIR_record],Fs);
    %soundsc([binIR_generate;gaptime;binIR_record],Fs);% only last 2 sound
end

% play controlRecord then generate IR conv with dry guitar
% 1.S3L3 2.generete 3.target recoeding
% 这里用一个干声(dry)信号与三种不同的IR做卷积来比较真实听感
doBinRenderSONG=0;
if doBinRenderSONG
    %song_Dry=audioread('speechdirectsound_48.wav');
    [~,ch]=size(song_Dry);
    if ch==2
        song_Dry=(song_Dry(:,1)+song_Dry(:,2))/2;
    end
    
    clear binSong_recordIR;
    clear binSong_originalIR;
    clear binSong_generateIR;
    
    for i=1:2 % L and R
        binSong_originalIR(:,i)=conv(song_Dry,binIR_original(:,i));
        binSong_generateIR(:,i)=conv(song_Dry,binIR_generate(:,i));
        binSong_recordIR(:,i)=conv(song_Dry,binIR_record(:,i));
    end
    
    gaptime=zeros(0.5*fs,2);% gap 0.5s*fs
    soundsc([binSong_originalIR;gaptime;binSong_generateIR;gaptime;binSong_recordIR],fs);
    
    if ~exist('Max')
        Max=1;
    end
    
    audiowrite(['S',num2str(targetSpeaker),'L',num2str(targetListener),'_Original33','.wav'],binSong_originalIR/Max,fs);
    audiowrite(['S',num2str(targetSpeaker),'L',num2str(targetListener),'_Rotate','.wav'],binSong_generateIR/Max,fs);
    %audiowrite(['S',num2str(useSpeaker),'L',num2str(useListener),'_Record','.wav'],binSong_recordIR/Max,fs);
end

%% declare function
%Find  direct sound loc and val
% 该函数用于找到直达声在IR中的索引和振幅（利用findpeaks在一定门限后找第一个峰）
function [locD,ValD,pks,lcs]=findDirectSound(ir)
absir=abs(ir);
noiseValuse=max(absir);
[pks,lcs]=findpeaks(absir,"MinPeakDistance",10,MinPeakHeight=0.2*noiseValuse);  %denosing,find peak
% Find the index of the peak representing the direct sound
locD=lcs(1);
ValD=pks(1);
end

% find A0 and alpha for distance - amipitude fit
% 该函数是用于计算指数衰减模型的误差和，用于fminsearch拟合出最优参数
function sse = sseval(x,tdata,ydata)
A = x(1);
lambda = x(2);
sse = sum((ydata - A*exp(-lambda*tdata)).^2);
end

% 该函数用于将高阶Ambisonics IR转换为双耳信号
function binIR=binSound(IR_test,SH_ambisonic_binaural_decoder)% render to a bin audio and play it
ambisonic_soundscape=IR_test.';

binaural_ambisonic_render = zeros(length(SH_ambisonic_binaural_decoder(1,:,1))+length(ambisonic_soundscape)-1,length(SH_ambisonic_binaural_decoder(1,1,:)));

% convolve each channel of the encoded signal with the decoder signal and sum the result
for i = 1:length(SH_ambisonic_binaural_decoder(:,1,1))
    
    binaural_ambisonic_render(:,1) = binaural_ambisonic_render(:,1) +  conv(SH_ambisonic_binaural_decoder(i,:,1),ambisonic_soundscape(:,i) );
    binaural_ambisonic_render(:,2) = binaural_ambisonic_render(:,2) +  conv(SH_ambisonic_binaural_decoder(i,:,2),ambisonic_soundscape(:,i) );
end

% compare the two binaural decoders by listening to both binaural renders consecutively
binIR=binaural_ambisonic_render;
end